package com.zurtar.mhma.data

import android.util.Log
import com.google.firebase.Firebase
import com.google.firebase.auth.auth
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.toObjects
import com.zurtar.mhma.chatbot.ChatBranch
import com.zurtar.mhma.chatbot.Sender
import com.zurtar.mhma.data.models.DateSerializer
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.tasks.await
import kotlinx.serialization.Serializable
import java.util.Date
import javax.inject.Inject
import javax.inject.Singleton


/*
ChatMessage is used to sore individual messages in chat logs. Lists of messages
are used for displaying different chats.

information about whether the message was generated by the bot or the user
the content of the message, and the time the message was created.
 */

@Serializable
data class ChatMessage(
    val sender: Sender = Sender.Null,
    val message: String = "",

    @Serializable(with = DateSerializer::class)
    var createdAt: Date? = null
)

/*
Represents a log of a specific chat activity or interaction. Using the logType variable, different
outputs for ChatLogPage are determined. ChatLog objects that get stored do not contain any messages
sent from the bot. They only contain messages from the user--since we already know all of the
chatbot's output based on the logType--to save memory.
 */

@Serializable
data class ChatLog(
    var id: String? = null,
    var logType: ChatBranch? = null,
    var content: List<ChatMessage> = listOf(),

    @Serializable(with = DateSerializer::class)
    var createdAt: Date? = null,

    @Serializable(with = DateSerializer::class)
    var toBeCompleted: Date? = null
)


@Singleton
class ChatRepository @Inject constructor(
    private var chatRemoteDataSource: ChatRemoteDataSource
) {
    suspend fun addLog(log: ChatLog) =
        chatRemoteDataSource.addLog(log)

    suspend fun deleteLog(log: ChatLog) =
        chatRemoteDataSource.deleteLog(log)

    suspend fun deleteLog(id: String) =
        chatRemoteDataSource.deleteLog(id)

    fun getChatLogs(): Flow<List<ChatLog>> =
        chatRemoteDataSource.getChatLogs()
}


@Singleton
class ChatRemoteDataSource @Inject constructor(
    private val fireStoreDatasource: FirebaseFirestore
) {
    private val TAG: String = "JournalRemoteDataSource"

    private val collectionRef = fireStoreDatasource.collection("users")
        .document(Firebase.auth.currentUser?.uid!!)
        .collection("ChatLogs")

    suspend fun addLog(branch: ChatBranch, messageList: List<ChatMessage>) {

    }

    suspend fun addLog(log: ChatLog) {
        if (log.id == null)
            return
        val response = collectionRef
            .document(log.id!!)
            .set(log).await()
    }

    suspend fun deleteLog(log: ChatLog) {
        if (log.id == null)
            return
        val response = collectionRef
            .document(log.id!!)
            .delete().await()
    }

    suspend fun deleteLog(id: String) {
        val response = collectionRef
            .document(id)
            .delete().await()
    }

    fun getChatLogs(): Flow<List<ChatLog>> = callbackFlow {
        val listenerRegistration = collectionRef.addSnapshotListener { snapshot, e ->
            if (e != null) {
                Log.w(TAG, "Listen failed.", e)
                return@addSnapshotListener
            }

            snapshot?.toObjects<ChatLog>()?.let { trySend(it) }
        }

        trySend(listOf<ChatLog>())
        awaitClose { listenerRegistration.remove() }
    }

}